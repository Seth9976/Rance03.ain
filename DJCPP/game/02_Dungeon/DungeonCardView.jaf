DungeonCardView::DungeonCardView()
{
	this.gameObjectId_ = g_gameObjectManager.addFocusObject(this.update, this.isHover);
	this.isPurge_ = false;
	this.isEnable_ = false;
	this.isClicked_ = false;
	this.isHover_ = false;
}

void DungeonCardView::setFinishCardOpenCallback(DG_GeneralCallback onFinishOpenCallback)
{
	this.onFinishOpenCallback_ = onFinishOpenCallback;
}

void DungeonCardView::init(ref DungeonCard card, DG_CardClickCallback onClickCallback, int clickId, int r, int g, int b)
{
	this.r_ = r;
	this.g_ = b;
	this.b_ = b;
	this.card_ <- card;
	this.onClickCallback_ = onClickCallback;
	this.clickId_ = clickId;
	this.card_.setCardOpenCallback(this.onOpenCard);
	this.card_.setCardChangedCallback(this.onChangeCard);
	this.initParts();
	this.setPartsShow();
	this.setPartsOrigin();
	this.setPartsOpenState();
}

void DungeonCardView::onChangeCard()
{
	if (this.isClicked_)
	{
		return;
	}
	this.initParts();
	this.setPartsShow();
	this.setPartsOrigin();
	this.setPartsOpenState();
}

void DungeonCardView::initParts()
{
	this.info_ <- getCardInfomationFromId(this.card_.getCardTypeId());
	this.parts_[0].init(this.info_.getBgImageName(), 0);
	if (Ａ＿ＣＧ存在確認(this.info_.getImageName()))
	{
		this.parts_[1].init(this.info_.getImageName(), 0);
	}
	else
	{
		this.parts_[1].initAsPlaneImage(this.parts_[0].getWidth(), this.parts_[0].getHeight(), 255, 255, 128, 255);
	}
	this.parts_[2].initAsCgPlaneImage(this.info_.getBgImageName(), 255, 255, 0);
	this.parts_[3].initAsText(this.info_.getCaption(), 24, true, 256, 255, 255, 255);
	string cb = this.info_.getClickableJudgeCallback();
	this.isNotCard_ = cb == "通行不可";
	this.parts_[4].initAsCgPlaneImage(this.info_.getImageName(), this.r_, this.g_, this.b_);
	this.parts_[2].setAlpha(128.0);
	this.adjustTextWidth();
	createPartsGroup(this.parent_, this.parts_, 1100);
	this.height_ = this.parts_[1].getHeight();
}

void DungeonCardView::adjustTextWidth()
{
	int w = this.parts_[3].getWidth();
	int cW = this.parts_[1].getWidth();
	if (cW * 0.9 < w)
	{
		this.parts_[3].setXScaling((100 * (cW * 0.9)) / w);
	}
}

void DungeonCardView::setPartsZPos()
{
	int n = (10 - this.localY_) * 30.0;
	this.parent_.setZ(1100 + n);
}

void DungeonCardView::setPartsAlpha()
{
	this.parent_.setAlpha(this.getPartsAlpha());
}

int DungeonCardView::getPartsAlpha()
{
	int a = 255;
	if (this.localY_ < 0.0)
	{
		a = Math.MaxF(0.0, this.localY_ + 1.0) * 255.0;
	}
	else if (this.localY_ > 4.0)
	{
		float n = Math.MinF(1.0, this.localY_ - 4.0);
		a = (1 - n) * 255.0;
	}
	if (this.isPurge_)
	{
		a -= Math.Min(255, (this.purgeTimer_.getTime() / 130.0) * 255.0);
	}
	return a;
}

void DungeonCardView::setPartsShadow()
{
	float p = Math.MinF(5.0, Math.MaxF(0.0, this.localY_));
	int c = (p / 5.0) * 255.0;
	if (g_playerCommonParam.getBadConditionTurn("閉店") > 0)
	{
		c = Math.Min(255, this.localY_ * 255.0);
	}
	this.parts_[4].setAlpha(c);
}

void DungeonCardView::setPartsShow()
{
	int i;
	for (i = 0; i < this.parts_.Numof(); ++i)
	{
		this.parts_[i].setShow(true);
	}
	this.parent_.setShow(true);
	this.parts_[2].setShow(false);
}

void DungeonCardView::setPartsOrigin()
{
	int i;
	for (i = 0; i < this.parts_.Numof(); ++i)
	{
		this.parts_[i].setOrigin(5);
	}
	this.parent_.setOrigin(5);
}

void DungeonCardView::setPartsOpenState()
{
	if (this.card_.isOpen())
	{
		this.parts_[0].setXZRot(180.0);
		this.parts_[1].setXZRot(0.0);
		this.parts_[3].setShow(true);
	}
	else
	{
		this.parts_[0].setXZRot(0.0);
		this.parts_[1].setXZRot(180.0);
		this.parts_[3].setShow(false);
	}
}

void DungeonCardView::setPartsTransformedPosition()
{
	this.getPartsTransformedPosition(this.screenX_, this.screenY_, this.scale_);
	this.parent_.setPos(this.screenX_, this.screenY_);
	this.parent_.setScaling(this.scale_ * 100.0);
}

void DungeonCardView::getPartsTransformedPosition(ref float x, ref float y, ref float scaling)
{
	float lx = this.localX_ - this.cameraX_;
	scaling = 1 - this.localY_ * 0.08;
	x = 512 + lx * (170 * scaling);
	y = 346 - this.localY_ * scaling * 50.0;
	y -= ((this.height_ - 240.0) / 2.0) * scaling;
	if (this.isNotCard_)
	{
		y += 20.0;
	}
}

void DungeonCardView::update()
{
	this.updateHover();
	if (this.isHover_ != this.lastHover_)
	{
		this.parts_[2].setShow(this.isHover_);
	}
	if (!this.lastHover_ && this.isHover_)
	{
		playCursor();
	}
	if (this.isHover_ && g_mouse.onDown(0) && !this.isClicked_)
	{
		playClick();
	}
	if (this.state_ == 0)
	{
		if (this.isHover() && g_mouse.isClickWithFocus(this.gameObjectId_))
		{
			this.isClicked_ = true;
			this.onClickCallback_(this.clickId_);
		}
	}
	this.lastHover_ = this.isHover_;
}

void DungeonCardView::updateHover()
{
	this.isHover_ = this.getHoverState();
}

void DungeonCardView::setCameraPos(float x)
{
	this.cameraX_ = x;
	this.setPartsTransformedPosition();
}

void DungeonCardView::setLocalPos(float x, float y)
{
	if (this.state_ == 2 || this.state_ == 5)
	{
		return;
	}
	this.localX_ = x;
	this.localY_ = y;
	this.setPartsTransformedPosition();
	this.setPartsZPos();
	this.setPartsAlpha();
	this.setPartsShadow();
}

void DungeonCardView::onFinishCardOpen()
{
	this.onFinishOpenCallback_();
	this.state_ = 0;
}

void DungeonCardView::onFinishChangeCardType()
{
	this.state_ = 0;
}

void DungeonCardView::onOpenCard()
{
	PartsMotion m1;
	m1.setTime(500);
	m1.setKey(4, 0, 180, 4);
	this.parts_[0].runMotion(m1, NULL);
	array@PartsMotion m2[2];
	m2[0].setKey(4, 180, 0, 4);
	m2[0].setTime(400);
	m2[1].setTime(400);
	this.parts_[3].setShow(true);
	g_sysSound.play(6, "効果音／カードめくる");
	this.parts_[3].runMotionArray(m2, NULL);
	this.parts_[1].runMotionArray(m2, this.onFinishCardOpen);
	this.state_ = 3;
}

bool DungeonCardView::isHover()
{
	this.updateHover();
	return this.isHover_;
}

bool DungeonCardView::getHoverState()
{
	return this.isClickable() && this.isMouseCursorOnCard();
}

bool DungeonCardView::isClickable()
{
	return this.isEnable_ && this.localY_ == 0.0 && this.info_.isClickable() && this.state_ == 0;
}

bool DungeonCardView::isMouseCursorOnCard()
{
	int x = g_mouse.getX();
	int y = g_mouse.getY();
	return AFL_Parts_IsPointIn(this.parts_[0].getPartsNumber(), x, y, 1) || AFL_Parts_IsPointIn(this.parts_[1].getPartsNumber(), x, y, 1);
}

ref DungeonCard DungeonCardView::getDungeonCard()
{
	return this.card_;
}

void DungeonCardView::purge()
{
	this.isPurge_ = true;
	this.purgeTimer_.setTimer(130, NULL);
}

void DungeonCardView::fadeIn(bool val, DG_GeneralCallback callback)
{
	this.state_ = val ? 1 : 2;
	this.onFinishFadeInCallback_ = callback;
	float x;
	float y;
	float scale;
	this.getPartsTransformedPosition(x, y, scale);
	if (val)
	{
		array@PartsMotion m[2];
		m[0].setAlpha(0, 0, 0);
		m[0].setTime(this.localX_ * 5.0 + this.localY_ * 80.0);
		m[1].setAlpha(0, this.getPartsAlpha(), 0);
		m[1].setMove(x, y - 200.0, x, y, 1);
		this.parent_.runMotionArray(m, this.onFinishFadeIn);
	}
	else
	{
		PartsMotion m;
		m.setAlpha(this.getPartsAlpha(), 0, 0);
		this.parent_.runMotion(m, this.onFinishFadeIn);
	}
}

void DungeonCardView::onFinishFadeIn()
{
	this.state_ = this.state_ == 1 ? 0 : 5;
	this.onFinishFadeInCallback_();
}

void DungeonCardView::setEnable(bool val)
{
	this.isEnable_ = val;
}

