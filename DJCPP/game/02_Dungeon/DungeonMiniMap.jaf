DungeonMiniMap::DungeonMiniMap()
{
	this.gameObjectId_ = g_gameObjectManager.addObject(this.update);
	this.viewDepth_ = 10;
}

void DungeonMiniMap::init(string dungeonId)
{
	this.dungeonId_ = dungeonId;
	ref Dungeon d = getDungeonFromId(this.dungeonId_);
	this.parts_[0].init("ダンジョン／ミニマップ／下地", 0);
	this.parts_[0].setPos(787.0, 221.0);
	this.parts_[1].initAsUserStructure();
	int pn = this.parts_[1].getPartsNumber();
	int depth = Math.Max(this.viewDepth_, d.getDepth()) + this.viewDepth_;
	if (depth * 13 > 2048)
	{
		pass("でかすぎるのでMinimapを生成しません");
		return;
	}
	Ｐ＿構築手順＿作成(pn, d.getWidth() * 13, depth * 13, 1);
	Ｐ＿構築手順＿色塗り(pn, 0, 0, d.getWidth() * 13, depth * 13, 0, 0, 0, 0, 1);
	int i;
	for (i = 0; i < depth; ++i)
	{
		ref DungeonLine ln = d.getDungeonLine(i);
		int j;
		for (j = 0; j < d.getWidth(); ++j)
		{
			ref DungeonCard dc = ln.getDungeonCard(j);
			CardInfomation info;
			info = getCardInfomationFromId(dc.getCardTypeId());
			if (info.isClickable())
			{
				if (info.getMinimapIconImageName().Empty())
				{
					Ｐ＿構築手順＿色塗り(pn, j * 13, (depth - i - 1) * 13, 12, 12, 255, 255, 255, 255, 1);
				}
				else
				{
					Ｐ＿構築手順＿ＣＧ部分コピー(pn, info.getMinimapIconImageName(), j * 13, (depth - i - 1) * 13, 0, 0, 12, 12, 1);
				}
			}
		}
		if (i % d.getDepth() == 0)
		{
			Ｐ＿構築手順＿色塗り(pn, 0, (depth - i) * 13 - 2, d.getWidth() * 13, 2, 255, 0, 0, 255, 1);
		}
	}
	Ｐ＿構築ビルド(pn, 1);
	this.initParts();
	this.parts_[1].setOrigin(2);
	this.parts_[2].init("ダンジョン／ミニマップ／アルファ", 0);
	this.parts_[2].setPos(791.0, 233.0);
	this.parts_[1].setAlphaClipperParts(this.parts_[2].getPartsNumber());
	this.parts_[3].init("ダンジョン／ミニマップ／カレント", 0);
	this.parts_[3].setPos(877.0, 382.0);
	createPartsGroup(this.parent_, this.parts_, 1950);
	this.setPartsShow();
	this.parts_[2].setShow(false);
}

void DungeonMiniMap::initParts()
{
}

void DungeonMiniMap::setPlayerPos(int x, int y)
{
	int depth = getDungeonFromId(this.dungeonId_).getDepth();
	int fromY = (this.y_ % depth) * 13;
	int toY = (y % depth) * 13;
	int baseX = 898;
	int baseY = 396;
	if (toY < fromY)
	{
		array@PartsMotion m[2];
		m[0].setMove(baseX - this.x_ * 13, baseY + fromY, baseX - x * 13, baseY + depth * 13, 1);
		m[1].setTime(0);
		m[1].setMove(baseX - x * 13, baseY + toY, baseX - x * 13, baseY + toY, 1);
		this.parts_[1].runMotionArray(m, NULL);
	}
	else
	{
		PartsMotion m;
		m.setMove(baseX - this.x_ * 13, baseY + fromY, baseX - x * 13, baseY + toY, 1);
		this.parts_[1].runMotion(m, NULL);
	}
	this.x_ = x;
	this.y_ = y;
}

void DungeonMiniMap::setPartsShow()
{
	int i;
	for (i = 0; i < this.parts_.Numof(); ++i)
	{
		this.parts_[i].setShow(true);
	}
}

void DungeonMiniMap::setPartsPos()
{
}

void DungeonMiniMap::update()
{
}

void DungeonMiniMap::fadeIn(bool val)
{
	PartsMotion m;
	if (val)
	{
		m.setAlpha(0, 255, 0);
	}
	else
	{
		m.setAlpha(255, 0, 0);
	}
	this.parent_.setShow(true);
	this.parent_.runMotion(m, NULL);
}

